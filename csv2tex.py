"""
csv2tex.py - process the CSV files for each section and emit the appropriate tex files

Why aren't we writing .tex files directly? Because we want to include the same data more than once,
differing only in sort order. In keeping with DRY, we write this once (in the CSV) and have this
utility handle the re-sort. 
"""
from collections import OrderedDict
from glob import iglob as glob
from pprint import pprint
from copy import copy
import csv
import hashlib
import sys

import pdb

###################
#  from https://stackoverflow.com/questions/5419/python-unicode-and-the-windows-console
import sys
def uprint(s):
    try:
        print(s)
    except UnicodeEncodeError:
        if sys.version_info >= (3,):
            print(s.encode('utf8').decode(sys.stdout.encoding))
        else:
            print(s.encode('utf8'))
#
###################

tabrows = set()
figrefs = {} # {figlabel : [(tabrow, caption), ...], ...}

def latexrow(lst, label=True):
	global tabrows
	global figrefs
	
#	sl = [i for e, i in enumerate(lst) if e not in omit] #sl = shorter list; list without columns from omit
	slt = (' & '.join(lst) + r" \\ \hline")
	
	if not label:
		return slt
	
	# generate a unique id for this row
	hash = hashlib.sha1(slt.encode()).hexdigest()
	while hash in tabrows:
		hash = hashlib.sha1((slt + hash).encode()).hexdigest()
	tabrows.add(hash)
	
	# update figure references
	lb = len(r"\ref{")
	if lst[-1] != "No Reference":
		rb = lst[-1].index('}')
		figrefs.setdefault(lst[-1][lb:rb], []).append((hash, lst[-2]))
	
	#return slt # test
	lab = '\phantomsection \label{' + hash + '} '
	return lab + slt

def getHead(cols):
	out = r"""
% AUTOMATICALLY GENERATED FILE
% Do not edit this file directly
% Instead, edit the .csv file from which it is generated

%\rowcolors{1}{white}{gray}
\begin{longtable}{@{}"""
	for r in range(cols-2):
		out += ' r'
	out += r"""
				  P{.75\textwidth} 
				  c
				  @{}}"""
	return out
	
def emit(name, header, items):
	header = [r"\textbf{" + i + "}" for i in header] #boldface
	with open(name, 'w', encoding='utf8') as of:
		print(getHead(len(header)), file=of)
		print(r"\hline", file=of)
		print(latexrow(header, False), file=of)
		print(r"\hline", file=of)
		print(r"\endfirsthead", file=of)
		print(r"\hline", file=of)
		print(latexrow(header, False), file=of)
		print(r"\hline", file=of)
		print(r"\endhead", file=of)
		for row in items:
			print(latexrow(row), file=of)
		print(r"\end{longtable}", file=of)
		
	print("	Wrote " + name)

def fixref(items,refcol):
	"Mark up the reference column of items. If empty, No Reference, otherwise \ref{item}"
	ret = []
	for row in items:
		#pdb.set_trace()
		head = row[:refcol-1]
		if len(row) < refcol or len(row[refcol-1]) == 0:
			c = "No Reference"
		else:
			c = r"\ref{" + row[refcol-1] + "}"
		if len(row) > refcol and len(row[refcol]) > 0:
			c += "-" + row[refcol]
		head.append(c)
		ret.append(head)
	return ret

class OrderedSet(object):
	"Super hacky way to preseve an ordering while eliminating duplicates"
	def __init__(self, it=None):
		self.set = set()
		self.list = []
		
		if it is not None:
			for i in it:
				self.add(i)
		
	def add(self, o):
		if o not in self.set:
			self.list.append(o)
			self.set.add(o)

def compSort(ll,c=[0],ci=False):
	"""
	Composite sort. Sorts a list of dimension >= 2 by the columns numbered in c, blanks last.
	If ci, case-insensitive. 
	"""
	ret = copy(ll)
	case = lambda x: x.lower() if ci else x
	while len(c) > 0:
		scol = c.pop()
		#if scol == 0:
		#	pdb.set_trace()
		try:
			ret.sort(key=lambda x: (len(x[scol]) == 0, int(x[scol]) if len(x[scol]) > 0 else sys.maxsize))
		except ValueError:
			ret.sort(key=lambda x: (len(x[scol]) == 0, case(x[scol])))
	return ret

def genBackref(figlabel):
	if figlabel not in figrefs:
		return ''
	
	ffl = figrefs[figlabel] # shorthand for the list of references to this figure
	
	lname = r"\backrefs" + hashlib.sha1(str(ffl).encode()).hexdigest()
	refdef  = r"\def" + lname + '{'
	refdef += ','.join((r"\getpagerefnumber{" + hash + '}' for hash, nomen in ffl))
	refdef += '}\n'
	
	return refdef
	
	
def figBackref(figlabel, caption):
	if figlabel not in figrefs:
		return caption
	if len(caption) > 0:
		caption += r"\\ \\ "
	
	ffl = figrefs[figlabel] # shorthand for the list of references to this figure
	
	lname = r"\backrefs" + hashlib.sha1(str(ffl).encode()).hexdigest()
#	caption += r"\def" + lname + '{'
#	caption += ','.join((r"\getpagerefnumber{" + hash + '}' for hash, nomen in ffl))
#	caption += '}\n'
	
	s = 's' if len(ffl) > 1 else ''
	caption += r"This figure was referenced on page" + s + ' '
	
	if len(ffl) == 1:
		caption += r"\pageref{" + ffl[0][0] + r"}" # + r"\footnote{" + ffl[0][1] + "}"
		return caption
	
	caption += r"\createlinks" + lname
	
	return caption
	
def main():
	references = OrderedSet()
	for section in sorted(glob('section*.csv')):
		with open(section, 'r', encoding='utf8') as scsv:
			scsvr = csv.reader(scsv)
			header = next(scsvr)
			lh = len(header)
			items = []
			for record in scsvr:
				items.append(record)
				if len(record) >= lh and len(record[lh-1]) > 0:  
					references.add(record[lh-1])
		
		print("Read " + section)
		
		
		sorts = [([0,2],[1],'a'), # <- sort, omit, postpend. Major sort 0 (first -17 order); minor 
		         ([1,2],[0],'b'), # sort 2 (nomenclature), omit 1 (second -17 order), postpend 'a' 
				 ([2],  [ ],'c')] # to the output file name. Other lines follow the same format.
				 
		#items = fixref(items)
		for sort, omit, postpend in sorts:
#			pdb.set_trace()
			outfn = section[:-4] + postpend + '.tex'
			sh = [i for e, i in enumerate(header) if e not in omit]
			si = [[i for e, i in enumerate(row) if e not in omit] for row in items] # si = short items
#			if postpend == 'c':
#				pdb.set_trace()
			fi = fixref(si,lh-len(omit)) # fi = fixed items
			
			emit(outfn, sh, compSort(fi, sort, True))
	
	# handle figures now
	with open('figures.csv', 'r', encoding='utf8') as fin:
		fcsvr = csv.reader(fin)
		items = OrderedDict()
		for record in fcsvr:
			items[record[0]] = record
		
	figs = set(items.keys())
	figs_without_refs = figs - references.set
	if len(figs_without_refs) > 0:
		for fwr in figs_without_refs:
			uprint("WARN: No reference exists to figure " + fwr)
	refs_without_figs = references.set - figs
	if len(refs_without_figs) > 0:
		# print(refs_without_figs)
		for rwf in refs_without_figs:
			uprint("WARN: No figure given for reference " + rwf)
	
	fig_order = []
	# now order the figures by first appearance in references
	for ref in references.list:
		if ref in items:
			fig_order.append(items[ref])
			del items[ref]
	# complete the rest of the unreferenced items
	fig_order.extend(items.values())
	
	#pprint(fig_order)
	
	with open('figures.tex', 'w', encoding='utf8') as fout:
		
		# LaTeX has trouble with lots of figures in a row, so let's give it a hand
		figcount = 0
		
		for ref, fn, caption in fig_order:
			print(r"\begin{figure}[htp]", file=fout)
			print(r"\includegraphics[width=\textwidth,height=7in,keepaspectratio]{Images/" + fn + "}", file=fout)
			gb = genBackref(ref)
			if len(gb) > 0:
				print(gb, file=fout)
			print(r"\caption{" + figBackref(ref, caption) + r" \label{" + ref + "}}", file=fout)
			print(r"\end{figure}", file=fout)
			
			figcount += 1
			if figcount >= 15:
				print (r"\clearpage", file=fout)
				figcount = 0

if __name__ == '__main__':
	main()